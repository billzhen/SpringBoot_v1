{"version":3,"sources":["compoments/ChatGPT/index.jsx","serviceWorker.js","index.js","compoments/ChatGPT/chatgpt.png","compoments/ChatGPT/user.png","compoments/ChatGPT/heike.gif","compoments/ChatGPT/qiu.gif","compoments/ChatGPT/jushou.gif"],"names":["them","dark","vscDarkPlus","light","coyWithoutShadows","App1","useState","comments","setComments","userName","setUserName","list_container_id","useRef","count","setCount","getList","title","requestList","map","item","push","name","contents","text","Promise","resolve","axios","post","frequency_penalty","max_tokens","model","presence_penalty","message","temperature","top_p","then","response","Array","isArray","data","choices","console","log","arr","index","content","alert","catch","error","scrollBottom","current","setTimeout","scrollTop","scrollHeight","updateScroll","useCallback","addComment","e","a","trim","length","id","Math","random","responseList","useEffect","className","style","flex","src","chatgpt","ref","el","color","key","user","marginLeft","ClickFingerTextBoard","dataList","display","justifyContent","backgroundColor","heike","type","placeholder","value","onChange","target","width","onClick","React","memo","list","isALL","setIsAll","innerAllText","calculatedFigures","position","marginBottom","textContent","language","darkMode","OmsSyntaxHighlight","props","darcula","SyntaxHighlighter","registerLanguage","jsx","javascript","source","escapeHtml","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","module","exports"],"mappings":"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","file":"static/js/main.a6873e87.chunk.js","sourcesContent":["\r\nimport React, { useContext, useState, useCallback, useRef } from 'react';\r\nimport './index.css';\r\nimport chatgpt from './chatgpt.png';\r\nimport user from './user.png';\r\nimport heike from './heike.gif';\r\nimport qiu from './qiu.gif';\r\nimport jushou from './jushou.gif';\r\nimport { useEffect } from 'react';\r\nimport axios from 'axios';\r\nimport { PrismLight as SyntaxHighlighter } from \"react-syntax-highlighter\";\r\nimport { vscDarkPlus, coyWithoutShadows, darcula } from 'react-syntax-highlighter/dist/esm/styles/prism';\r\n// 设置高亮的语言\r\nimport { jsx, javascript, sass, scss } from \"react-syntax-highlighter/dist/esm/languages/prism\";\r\nimport ReactMarkdown from 'react-markdown';\r\nconst them = {\r\n  dark: vscDarkPlus,\r\n  light: coyWithoutShadows\r\n};\r\nexport default function App1() {\r\n  const [comments, setComments] = useState([]);\r\n  const [userName, setUserName] = useState(\"\");\r\n  const list_container_id = useRef(null);\r\n  const [count, setCount] = useState(0);\r\n\r\n  const getList = (title) => {\r\n    let requestList = [];\r\n    comments.map((item) => {\r\n      requestList.push({ \"role\": \"user\", \"content\": item.name })\r\n      if (item.contents[0]) {\r\n        requestList.push({ \"role\": \"assistant\", \"content\": item.contents[0].text })\r\n      }\r\n    })\r\n\r\n    // return new Promise((resolve) => {\r\n    //   setTimeout(() => {\r\n    //     resolve([{ text: '大大所大所多大大所大所多大大所大所多大大所大所多大大所大![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)\\n大所大所多大大所大所多大大所大所多大大所大所多大大所大所多', index: 0 }]);\r\n    //   }, 2000)\r\n    // })\r\n    return new Promise((resolve) => {\r\n      axios.post('/search/send', {\r\n        frequency_penalty: 0,\r\n        max_tokens: 2048,\r\n        model: \"text-davinci-003\",\r\n        presence_penalty: 0,\r\n        message: requestList,\r\n        temperature: 0.5,\r\n        top_p: 1\r\n      }).then((response) => {\r\n\r\n        if (Array.isArray(response.data.choices)) {\r\n          console.log('请求成功', response);\r\n          let arr = response.data.choices.map((item) => {\r\n            return {\r\n              index: item.index,\r\n              text: item.message.content\r\n            }\r\n          })\r\n          resolve(arr);\r\n        } else {\r\n          alert('程序错误');\r\n        }\r\n        // 请求成功\r\n      }).catch((error) => {\r\n        // 请求失败，\r\n        console.log(error);\r\n      });\r\n    })\r\n  }\r\n  const scrollBottom = () => {\r\n    if (!list_container_id.current) {\r\n      return;\r\n    }\r\n    setTimeout(() => {\r\n      list_container_id.current.scrollTop = list_container_id.current.scrollHeight\r\n    }, 0);\r\n  }\r\n\r\n  const updateScroll = useCallback(() => {\r\n    scrollBottom()\r\n  })\r\n\r\n  const addComment = async (e) => {\r\n    if (userName.trim() === '') {\r\n      alert('请输入问题');\r\n      return;\r\n    }\r\n    setUserName('');\r\n    let index = comments.length;\r\n    comments.push({\r\n      id: Math.random(),\r\n      name: userName,\r\n      contents: []\r\n    });\r\n    setComments(comments);\r\n    setCount(count + 1);\r\n    setTimeout(async () => {\r\n      let responseList = await getList(userName);\r\n      comments[index].contents = responseList;\r\n      setComments(comments);\r\n      setUserName('');\r\n      setCount(0);\r\n    }, 0);\r\n  }\r\n\r\n\r\n  console.log('comments ==========', comments);\r\n  const renderList = () => {\r\n    return comments.length === 0 ?\r\n      (<div style={{ flex: 1 }}>\r\n        <div className='no-comment'>暂无问题，快去提问吧~</div>\r\n        <img className='chatGPTImg' src={chatgpt} />\r\n      </div>)\r\n      : (\r\n        <div\r\n          ref={(el) => {\r\n            list_container_id.current = el;\r\n          }}\r\n          style={{ flex: 1 }}\r\n          className=\"list_container\"\r\n        >\r\n          <ul style={{ color: 'white' }}>\r\n            {comments.map((item, index) => (\r\n              <li key={item.id} style={{ color: 'white' }}>\r\n                {\r\n                  item.name ? (\r\n                    <div\r\n                      className='quiz'>\r\n                      <img className='quiz_avatar' src={user} />\r\n                      <div className='response' style={{ marginLeft: 8 }}>提问： {item.name}</div>\r\n                    </div>\r\n                  ) : null\r\n                }\r\n                {\r\n                  item.contents.length ? (\r\n                    <div\r\n                      className='answer'>\r\n                      <img className='quiz_avatar' src={chatgpt} />\r\n                      <ClickFingerTextBoard dataList={item.contents} index={index} updateScroll={updateScroll} />\r\n                    </div>\r\n                  ) : <div>\r\n                    <div style={{ display: 'flex', justifyContent: 'center', backgroundColor: 'black' }}><img className='heike' src={heike} /></div>\r\n                    <div className='answer2'>思考中...</div>\r\n                  </div>\r\n                }\r\n              </li>\r\n            ))}\r\n          </ul>\r\n        </div>\r\n      )\r\n  }\r\n  const handleForm = (e) => {\r\n    setUserName(e.target.value)\r\n  }\r\n\r\n\r\n  // componentDidUpdate() {\r\n  //   this.scrollBottom()\r\n  // }\r\n  useEffect(() => {\r\n    scrollBottom()\r\n  })\r\n  console.log(\"Parent here.\")\r\n\r\n  // const { userName } = this.state;\r\n  return (\r\n    <div className='app_container'>\r\n      {renderList()}\r\n      <div className='input_style'>\r\n        <input\r\n          className='input_quertion'\r\n          type=\"text\"\r\n          placeholder=\"请输入问题\"\r\n          value={userName}\r\n          name=\"userName\"\r\n          onChange={handleForm}\r\n        />\r\n        <div style={{ width: '1vw' }}></div>\r\n        <button onClick={addComment} className=\"confirm_button\">发起提问</button>\r\n      </div>\r\n    </div>\r\n  )\r\n\r\n}\r\n\r\nconst ClickFingerTextBoard = React.memo(({ dataList, index, updateScroll }) => {\r\n  console.log('组件内部' + index + \"更新\");\r\n  const [list, setList] = useState(dataList);\r\n  const [count, setCount] = useState(1);\r\n  const [isALL, setIsAll] = useState(false);\r\n  let innerText = useRef([]);\r\n  let isNeedScrollDown = useRef(true);\r\n  let innerAllText = useRef([]);\r\n  let newList = useRef([]);\r\n  let timer1 = useRef(null)\r\n  let timer2 = useRef(null)\r\n\r\n\r\n  const delay = (time) => {\r\n    return new Promise((resolve) => {\r\n      let timers = setInterval(() => {\r\n        clearInterval(timers);\r\n        resolve();\r\n      }, time);\r\n    })\r\n  };\r\n\r\n\r\n  useEffect(() => {\r\n    const calculatedFigures = async () => {\r\n      list.map((item) => {\r\n        innerAllText.current.push(item.text);\r\n      })\r\n    }\r\n    calculatedFigures();\r\n    setIsAll(true);\r\n  }, [])\r\n\r\n\r\n  // useEffect(() => {\r\n  //   console.log('组件-useEffect' + index + \"更新\");\r\n  //   const calculatedFigures = async () => {\r\n  //     list.map((item) => {\r\n  //       newList.current.push(item.text.split(''));\r\n  //     })\r\n  //     timer1.current = setTimeout(async () => {\r\n  //       for (let i = 0; i < newList.current.length; i++) {\r\n  //         innerText.current.push([]);\r\n  //         for (let j = 0; j <= newList.current[i].length; j++) {\r\n  //           if (newList.current[i][j] === undefined) {\r\n  //             continue;\r\n  //           }\r\n  //           await delay(Math.random() * 100);\r\n  //           innerText.current[i] = innerText.current[i] + newList.current[i][j];\r\n  //           if (isNeedScrollDown.current) {\r\n  //             updateScroll();\r\n  //           }\r\n  //         }\r\n  //       }\r\n  //       setTimeout(() => {\r\n  //         clearTimeout(timer1.current);\r\n  //         clearInterval(timer2.current);\r\n  //       }, 1000)\r\n  //     }, 0);\r\n  //   }\r\n  //\r\n  //   if (list && list.length) {\r\n  //     calculatedFigures();\r\n  //     timer2.current = setInterval(() => {\r\n  //       setCount((count) => count + 1);\r\n  //     }, 100)\r\n  //   }\r\n  //   return () => {\r\n  //     clearTimeout(timer1.current);\r\n  //     clearInterval(timer2.current);\r\n  //   }\r\n  // }, [])\r\n\r\n  const textquickly = (index) => {\r\n    clearTimeout(timer1.current);\r\n    clearInterval(timer2.current);\r\n    isNeedScrollDown.current = false;\r\n    setTimeout(updateScroll(), 0);\r\n    setIsAll(true);\r\n  }\r\n  console.log(\"here\");\r\n  return (\r\n    <div style={{ position: 'relative', width: \"100%\" }}>\r\n      {/*<div style={{ width: 30 }}> <button onClick={() => { textquickly(index); }} className=\"quickButton\">加速</button></div>*/}\r\n      {/*<div>*/}\r\n      {/*  {*/}\r\n      {/*    !isALL && innerText.current.length && innerText.current.map((text, index) => {*/}\r\n      {/*      return <div style={{ marginLeft: 8, marginBottom: 10 }} key={index}>回答： <pre style={{ width: \"100%\" }}><OmsSyntaxHighlight textContent={text} language={\"javascript\"} darkMode /></pre></div>*/}\r\n      {/*    })*/}\r\n      {/*  }*/}\r\n      {/*</div>*/}\r\n      <div>{\r\n          isALL && innerAllText.current.length && innerAllText.current.map((text, index) => {\r\n            return <div style={{ marginLeft: 8, marginBottom: 10 }} key={index}>回答： <pre style={{ width: \"100%\" }}><OmsSyntaxHighlight textContent={text} language={\"javascript\"} darkMode /></pre></div>\r\n          })\r\n        }\r\n      </div>\r\n    </div>\r\n  )\r\n})\r\nconst OmsSyntaxHighlight = (props) => {\r\n  const { textContent, darkMode, language = 'txt' } = props;\r\n  const [value, setValue] = useState(textContent);\r\n  if (typeof darkMode === 'undefined') {\r\n    them.light = darcula;\r\n  }\r\n  if (typeof darkMode === 'boolean') {\r\n    them.light = coyWithoutShadows;\r\n  }\r\n  useEffect(() => {\r\n    SyntaxHighlighter.registerLanguage(\"jsx\", jsx);\r\n    SyntaxHighlighter.registerLanguage(\"javascript\", javascript);\r\n    SyntaxHighlighter.registerLanguage(\"js\", javascript);\r\n  }, []);\r\n  return (\r\n    <ReactMarkdown source={value} escapeHtml={false} language={language}>{textContent}</ReactMarkdown>\r\n  );\r\n};\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport Chatgpt from \"./compoments/ChatGPT\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Chatgpt />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/chatgpt.8b0cad56.png\";","module.exports = __webpack_public_path__ + \"static/media/user.12f71825.png\";","module.exports = __webpack_public_path__ + \"static/media/heike.729fd49e.gif\";","module.exports = __webpack_public_path__ + \"static/media/qiu.5b7b93a2.gif\";","module.exports = __webpack_public_path__ + \"static/media/jushou.a8ebfd24.gif\";"],"sourceRoot":""}